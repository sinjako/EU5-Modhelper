/**
 * Mod Writer for EU5 ModHelper
 * Writes edited items back to Paradox script format in mod folders
 */

class ModWriter {
    constructor() {
        this.supportsFileSystemAccess = 'showDirectoryPicker' in window;
    }

    /**
     * Write all pending changes to mod folder
     * @param {Object} mod - The mod object with directory handle
     * @param {Object} pendingEdits - { category: { itemName: itemData } }
     */
    async writeChanges(mod, pendingEdits) {
        if (!mod || !mod.directoryHandle) {
            return { success: false, error: 'No mod directory available' };
        }

        try {
            let filesWritten = 0;

            // Group edits by category
            for (const [category, items] of Object.entries(pendingEdits)) {
                const categoryPath = this.getCategoryPath(category);
                if (!categoryPath) {
                    console.warn(`Unknown category path for: ${category}`);
                    continue;
                }

                // Generate Paradox script content for all items in this category
                const content = this.generateScript(items);

                // Write to file
                const fileName = `${category}_modhelper.txt`;
                await this.writeFile(mod.directoryHandle, categoryPath, fileName, content);
                filesWritten++;
            }

            return { success: true, filesWritten };
        } catch (err) {
            console.error('Write error:', err);
            return { success: false, error: err.message };
        }
    }

    /**
     * Get the mod path for a category
     */
    getCategoryPath(category) {
        const categoryConfig = CategoryRegistry.get(category);
        if (!categoryConfig) return null;

        // Convert game path to mod path
        // game/in_game/common/religions -> in_game/common/religions
        let path = categoryConfig.path;
        if (path.startsWith('game/')) {
            path = path.substring(5);
        }
        return path;
    }

    /**
     * Write content to a file in the mod directory
     */
    async writeFile(modHandle, relativePath, fileName, content) {
        const parts = relativePath.split('/').filter(p => p);

        // Navigate/create directories
        let currentDir = modHandle;
        for (const part of parts) {
            try {
                currentDir = await currentDir.getDirectoryHandle(part, { create: true });
            } catch (err) {
                console.error(`Failed to create directory ${part}:`, err);
                throw err;
            }
        }

        // Create and write the file
        const fileHandle = await currentDir.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
    }

    /**
     * Generate Paradox script from JavaScript objects
     * @param {Object} items - { itemName: itemData }
     * @returns {string} Paradox script content
     */
    generateScript(items) {
        const lines = [
            '# Generated by EU5 ModHelper',
            `# Date: ${new Date().toISOString()}`,
            ''
        ];

        for (const [name, data] of Object.entries(items)) {
            lines.push(this.serializeItem(name, data, 0));
            lines.push('');
        }

        return lines.join('\n');
    }

    /**
     * Serialize a single item to Paradox script
     */
    serializeItem(name, data, indent) {
        const tabs = '\t'.repeat(indent);
        const lines = [`${tabs}${name} = {`];

        for (const [key, value] of Object.entries(data)) {
            // Skip internal properties
            if (key.startsWith('_')) continue;

            const serialized = this.serializeValue(key, value, indent + 1);
            if (serialized !== null) {
                lines.push(serialized);
            }
        }

        lines.push(`${tabs}}`);
        return lines.join('\n');
    }

    /**
     * Serialize a single property value
     */
    serializeValue(key, value, indent) {
        const tabs = '\t'.repeat(indent);

        if (value === null || value === undefined) {
            return null;
        }

        // Boolean
        if (typeof value === 'boolean') {
            return `${tabs}${key} = ${value ? 'yes' : 'no'}`;
        }

        // Number
        if (typeof value === 'number') {
            // Format with appropriate precision
            if (Number.isInteger(value)) {
                return `${tabs}${key} = ${value}`;
            } else {
                return `${tabs}${key} = ${value.toFixed(6).replace(/\.?0+$/, '')}`;
            }
        }

        // String
        if (typeof value === 'string') {
            // Check if it needs quotes (contains spaces or special chars)
            if (value.includes(' ') || value.includes('"') || value === '') {
                return `${tabs}${key} = "${value.replace(/"/g, '\\"')}"`;
            }
            return `${tabs}${key} = ${value}`;
        }

        // RGB Color
        if (value._type === 'rgb') {
            return `${tabs}${key} = rgb { ${Math.round(value.r)} ${Math.round(value.g)} ${Math.round(value.b)} }`;
        }

        // HSV Color
        if (value._type === 'hsv') {
            return `${tabs}${key} = hsv { ${value.h.toFixed(2)} ${value.s.toFixed(2)} ${value.v.toFixed(2)} }`;
        }

        // Date
        if (value._type === 'date') {
            return `${tabs}${key} = ${value.value}`;
        }

        // Array
        if (Array.isArray(value)) {
            if (value.length === 0) {
                return `${tabs}${key} = { }`;
            }

            // Check if simple array (all primitives)
            const allPrimitive = value.every(v =>
                typeof v !== 'object' || v === null
            );

            if (allPrimitive) {
                const vals = value.map(v => {
                    if (typeof v === 'boolean') return v ? 'yes' : 'no';
                    if (typeof v === 'string' && v.includes(' ')) return `"${v}"`;
                    return String(v);
                }).join(' ');
                return `${tabs}${key} = { ${vals} }`;
            }

            // Complex array
            const lines = [`${tabs}${key} = {`];
            for (const item of value) {
                if (typeof item === 'object' && item !== null) {
                    // Anonymous nested object
                    lines.push(this.serializeNestedObject(item, indent + 1));
                } else {
                    const formatted = this.formatPrimitive(item);
                    lines.push(`${'\t'.repeat(indent + 1)}${formatted}`);
                }
            }
            lines.push(`${tabs}}`);
            return lines.join('\n');
        }

        // Object (nested block)
        if (typeof value === 'object') {
            return this.serializeItem(key, value, indent);
        }

        return null;
    }

    /**
     * Serialize a nested anonymous object
     */
    serializeNestedObject(obj, indent) {
        const tabs = '\t'.repeat(indent);
        const lines = [`${tabs}{`];

        for (const [key, val] of Object.entries(obj)) {
            if (key.startsWith('_')) continue;
            const serialized = this.serializeValue(key, val, indent + 1);
            if (serialized) lines.push(serialized);
        }

        lines.push(`${tabs}}`);
        return lines.join('\n');
    }

    /**
     * Format a primitive value for script
     */
    formatPrimitive(value) {
        if (typeof value === 'boolean') return value ? 'yes' : 'no';
        if (typeof value === 'string' && value.includes(' ')) return `"${value}"`;
        return String(value);
    }
}

window.ModWriter = ModWriter;

/**
 * Mod Writer for EU5 ModHelper
 * Writes edited items back to Paradox script format in mod folders
 *
 * EU5 Modding Requirements:
 * - Files must be UTF-8 with BOM encoding
 * - Use REPLACE:key to override existing game definitions
 * - Use INJECT:key to add properties to existing definitions
 * - New items can be added without prefix
 */

class ModWriter {
    constructor() {
        this.supportsFileSystemAccess = 'showDirectoryPicker' in window;
        // UTF-8 BOM bytes
        this.UTF8_BOM = '\uFEFF';
    }

    /**
     * Write all pending changes to mod folder
     * @param {Object} mod - The mod object with directory handle
     * @param {Object} pendingEdits - { category: { itemName: itemData } }
     * @param {Object} baseItems - Base game items for comparison (to detect new vs modified)
     */
    async writeChanges(mod, pendingEdits, baseItems = {}) {
        if (!mod || !mod.directoryHandle) {
            return { success: false, error: 'No mod directory available' };
        }

        try {
            let filesWritten = 0;
            const fullFileCategories = [];

            for (const [category, items] of Object.entries(pendingEdits)) {
                const categoryConfig = CategoryRegistry.get(category);
                const categoryPath = this.getCategoryPath(category);
                if (!categoryPath) {
                    console.warn(`Unknown category path for: ${category}`);
                    continue;
                }

                // Get base items for this category
                const baseCategoryItems = baseItems[category] || {};

                let content;

                // Check if category requires full file output (e.g., map_data files)
                if (categoryConfig && categoryConfig.requiresFullFile) {
                    // Merge edits into full base file
                    const mergedItems = this.mergeIntoBase(baseCategoryItems, items);
                    // Generate without REPLACE: prefix since we're replacing the entire file
                    content = this.generateFullFileScript(mergedItems, category);
                    fullFileCategories.push(category);
                    console.log(`Writing full file for ${category} (${Object.keys(mergedItems).length} items)`);
                } else {
                    // Regular category - just write edits with REPLACE: prefix
                    content = this.generateScript(items, baseCategoryItems);
                }

                // Write to file with UTF-8 BOM
                const fileName = this.getCategoryFileName(category);
                await this.writeFile(mod.directoryHandle, categoryPath, fileName, content);
                filesWritten++;
            }

            return {
                success: true,
                filesWritten,
                fullFileCategories: fullFileCategories.length > 0 ? fullFileCategories : undefined
            };
        } catch (err) {
            console.error('Write error:', err);
            return { success: false, error: err.message };
        }
    }

    /**
     * Merge edited items into the full base items
     * @param {Object} baseItems - All base game items for this category
     * @param {Object} editedItems - Items that were edited
     * @returns {Object} Merged items (base + edits)
     */
    mergeIntoBase(baseItems, editedItems) {
        // Start with a copy of all base items
        const merged = {};

        // Copy base items (excluding internal properties at the category level)
        for (const [key, value] of Object.entries(baseItems)) {
            if (!key.startsWith('_')) {
                merged[key] = value;
            }
        }

        // Override with edited items
        for (const [key, value] of Object.entries(editedItems)) {
            merged[key] = value;
        }

        return merged;
    }

    /**
     * Generate Paradox script for full file output (no REPLACE: prefix)
     * Used for categories that don't support partial overrides
     * @param {Object} items - All items to write
     * @param {string} category - Category name for header
     * @returns {string} Paradox script content
     */
    generateFullFileScript(items, category) {
        const lines = [
            '# Generated by EU5 ModHelper',
            `# Date: ${new Date().toISOString()}`,
            `# Full file replacement for ${category}`,
            ''
        ];

        for (const [name, data] of Object.entries(items)) {
            // Skip internal properties
            if (name.startsWith('_')) continue;

            // No REPLACE: prefix - we're replacing the entire file
            lines.push(this.serializeItem(name, data, 0));
            lines.push('');
        }

        return lines.join('\n');
    }

    /**
     * Get the mod path for a category
     */
    getCategoryPath(category) {
        const categoryConfig = CategoryRegistry.get(category);
        if (!categoryConfig) return null;

        // Convert game path to mod path
        // game/in_game/common/religions -> in_game/common/religions
        let path = categoryConfig.path;
        if (path.startsWith('game/')) {
            path = path.substring(5);
        }
        return path;
    }

    /**
     * Get the filename for a category's mod file
     * Uses specialFile if defined (for categories where EU5 only loads specific filenames)
     * Uses correct extension based on category config
     */
    getCategoryFileName(category) {
        const categoryConfig = CategoryRegistry.get(category);
        if (!categoryConfig) return `${category}_modhelper.txt`;

        // If category has a specialFile, use that name (EU5 only loads that specific file)
        if (categoryConfig.specialFile) {
            return categoryConfig.specialFile;
        }

        // Determine file extension based on category config
        // GUI files use .gui extension, everything else uses .txt
        const extension = categoryConfig.extensions && categoryConfig.extensions.includes('.gui')
            ? '.gui'
            : '.txt';

        return `${category}_modhelper${extension}`;
    }

    /**
     * Write content to a file in the mod directory with UTF-8 BOM
     */
    async writeFile(modHandle, relativePath, fileName, content) {
        const parts = relativePath.split('/').filter(p => p);

        // Navigate/create directories
        let currentDir = modHandle;
        for (const part of parts) {
            currentDir = await currentDir.getDirectoryHandle(part, { create: true });
        }

        // Create and write the file with UTF-8 BOM
        const fileHandle = await currentDir.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();

        // Write UTF-8 BOM + content
        const contentWithBOM = this.UTF8_BOM + content;
        await writable.write(contentWithBOM);
        await writable.close();
    }

    /**
     * Generate Paradox script from JavaScript objects
     * @param {Object} items - { itemName: itemData }
     * @param {Object} baseItems - Base game items for this category
     * @returns {string} Paradox script content
     */
    generateScript(items, baseItems = {}) {
        const lines = [
            '# Generated by EU5 ModHelper',
            `# Date: ${new Date().toISOString()}`,
            ''
        ];

        for (const [name, data] of Object.entries(items)) {
            // Determine if this is a new item or modifying existing
            const isModifyingExisting = name in baseItems;

            // Use REPLACE: prefix for existing items, no prefix for new items
            const prefix = isModifyingExisting ? 'REPLACE:' : '';

            lines.push(this.serializeItem(prefix + name, data, 0));
            lines.push('');
        }

        return lines.join('\n');
    }

    /**
     * Serialize a single item to Paradox script
     */
    serializeItem(name, data, indent) {
        const tabs = '\t'.repeat(indent);
        const lines = [`${tabs}${name} = {`];

        for (const [key, value] of Object.entries(data)) {
            // Skip internal properties
            if (key.startsWith('_')) continue;

            const serialized = this.serializeValue(key, value, indent + 1);
            if (serialized !== null) {
                lines.push(serialized);
            }
        }

        lines.push(`${tabs}}`);
        return lines.join('\n');
    }

    /**
     * Serialize a single property value
     */
    serializeValue(key, value, indent) {
        const tabs = '\t'.repeat(indent);

        if (value === null || value === undefined) {
            return null;
        }

        // Boolean
        if (typeof value === 'boolean') {
            return `${tabs}${key} = ${value ? 'yes' : 'no'}`;
        }

        // Number
        if (typeof value === 'number') {
            if (Number.isInteger(value)) {
                return `${tabs}${key} = ${value}`;
            }
            return `${tabs}${key} = ${value.toFixed(6).replace(/\.?0+$/, '')}`;
        }

        // String
        if (typeof value === 'string') {
            if (value.includes(' ') || value.includes('"') || value === '') {
                return `${tabs}${key} = "${value.replace(/"/g, '\\"')}"`;
            }
            return `${tabs}${key} = ${value}`;
        }

        // RGB Color
        if (value._type === 'rgb') {
            return `${tabs}${key} = rgb { ${Math.round(value.r)} ${Math.round(value.g)} ${Math.round(value.b)} }`;
        }

        // HSV Color
        if (value._type === 'hsv') {
            return `${tabs}${key} = hsv { ${value.h.toFixed(2)} ${value.s.toFixed(2)} ${value.v.toFixed(2)} }`;
        }

        // Date
        if (value._type === 'date') {
            return `${tabs}${key} = ${value.value}`;
        }

        // Array
        if (Array.isArray(value)) {
            return this.serializeArray(key, value, indent);
        }

        // Object (nested block)
        if (typeof value === 'object') {
            return this.serializeItem(key, value, indent);
        }

        return null;
    }

    /**
     * Serialize an array value
     */
    serializeArray(key, value, indent) {
        const tabs = '\t'.repeat(indent);

        if (value.length === 0) {
            return `${tabs}${key} = { }`;
        }

        // Check if simple array (all primitives)
        const allPrimitive = value.every(v => typeof v !== 'object' || v === null);

        if (allPrimitive) {
            const vals = value.map(v => {
                if (typeof v === 'boolean') return v ? 'yes' : 'no';
                if (typeof v === 'string' && v.includes(' ')) return `"${v}"`;
                return String(v);
            }).join(' ');
            return `${tabs}${key} = { ${vals} }`;
        }

        // Complex array
        const lines = [`${tabs}${key} = {`];
        for (const item of value) {
            if (typeof item === 'object' && item !== null) {
                lines.push(this.serializeNestedObject(item, indent + 1));
            } else {
                lines.push(`${'\t'.repeat(indent + 1)}${this.formatPrimitive(item)}`);
            }
        }
        lines.push(`${tabs}}`);
        return lines.join('\n');
    }

    /**
     * Serialize a nested anonymous object
     */
    serializeNestedObject(obj, indent) {
        const tabs = '\t'.repeat(indent);
        const lines = [`${tabs}{`];

        for (const [key, val] of Object.entries(obj)) {
            if (key.startsWith('_')) continue;
            const serialized = this.serializeValue(key, val, indent + 1);
            if (serialized) lines.push(serialized);
        }

        lines.push(`${tabs}}`);
        return lines.join('\n');
    }

    /**
     * Format a primitive value for script
     */
    formatPrimitive(value) {
        if (typeof value === 'boolean') return value ? 'yes' : 'no';
        if (typeof value === 'string' && value.includes(' ')) return `"${value}"`;
        return String(value);
    }
}

window.ModWriter = ModWriter;

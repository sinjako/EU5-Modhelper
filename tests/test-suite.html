<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EU5 Inspector - Test Suite</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', sans-serif; background: #1a1a2e; color: #e0e0e0; padding: 20px; }
        h1 { color: #e94560; margin-bottom: 20px; }
        h2 { color: #61afef; margin: 20px 0 10px; font-size: 1.2rem; }

        .test-controls { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { background: #e94560; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; }
        button:hover { background: #ff6b6b; }
        button:disabled { background: #555; }
        input[type="file"] { display: none; }
        .folder-btn { background: #61afef; }

        .test-section { background: #16213e; border-radius: 8px; padding: 15px; margin-bottom: 15px; }
        .test-result { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 4px; margin: 5px 0; }
        .test-result.pass { background: rgba(98, 175, 239, 0.2); }
        .test-result.fail { background: rgba(233, 69, 96, 0.2); }
        .test-result.pending { background: rgba(229, 192, 123, 0.2); }
        .status { font-size: 1.2rem; }
        .pass .status { color: #98c379; }
        .fail .status { color: #e94560; }
        .pending .status { color: #e5c07b; }
        .test-name { flex: 1; }
        .test-detail { font-size: 0.85rem; color: #888; }

        .visual-test { border: 1px solid #0f3460; border-radius: 8px; padding: 15px; margin: 10px 0; }
        .visual-test h3 { color: #c9a227; margin-bottom: 10px; font-size: 1rem; }
        .visual-preview { background: #0d0d1a; border-radius: 4px; padding: 15px; min-height: 100px; }

        .grid-test { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; }
        .grid-item { background: #c9a227; color: #000; padding: 20px; text-align: center; border-radius: 4px; }

        .summary { position: fixed; top: 20px; right: 20px; background: #16213e; padding: 15px; border-radius: 8px; border: 1px solid #0f3460; }
        .summary-stat { display: flex; justify-content: space-between; gap: 20px; margin: 5px 0; }

        pre { background: #0d0d1a; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.85rem; }
        .error { color: #e94560; }
    </style>
</head>
<body>
    <h1>EU5 Inspector Test Suite</h1>

    <div class="summary" id="summary">
        <div class="summary-stat"><span>Passed:</span><span id="pass-count">0</span></div>
        <div class="summary-stat"><span>Failed:</span><span id="fail-count">0</span></div>
        <div class="summary-stat"><span>Pending:</span><span id="pending-count">0</span></div>
    </div>

    <div class="test-controls">
        <button class="folder-btn" id="load-btn">Load EU5 Folder</button>
        <button id="run-all">Run All Tests</button>
        <button id="run-parser">Test Parser</button>
        <button id="run-tree">Test Tree Builder</button>
        <button id="run-filtering">Test Filtering</button>
        <button id="run-visual">Test Visual Layout</button>
    </div>

    <div id="test-output"></div>

    <script src="../js/parser.js"></script>
    <script>
        // Test state
        const state = {
            files: new Map(),
            folderName: '',
            rawData: {},
            treeData: {},
            results: { pass: 0, fail: 0, pending: 0 }
        };

        const output = document.getElementById('test-output');

        // File loading
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.webkitdirectory = true;
        document.body.appendChild(fileInput);

        document.getElementById('load-btn').onclick = () => fileInput.click();
        fileInput.onchange = async (e) => {
            state.files.clear();
            const files = e.target.files;
            state.folderName = files[0].webkitRelativePath.split('/')[0];
            for (const file of files) {
                const rel = file.webkitRelativePath.substring(state.folderName.length + 1);
                state.files.set(rel, file);
            }
            log(`Loaded ${state.files.size} files from ${state.folderName}`);
            document.getElementById('run-all').disabled = false;
        };

        function log(msg) {
            console.log(msg);
        }

        function updateSummary() {
            document.getElementById('pass-count').textContent = state.results.pass;
            document.getElementById('fail-count').textContent = state.results.fail;
            document.getElementById('pending-count').textContent = state.results.pending;
        }

        function addSection(title) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h2>${title}</h2>`;
            output.appendChild(section);
            return section;
        }

        function addResult(section, name, passed, detail = '') {
            const status = passed === null ? 'pending' : (passed ? 'pass' : 'fail');
            const icon = passed === null ? '‚è≥' : (passed ? '‚úì' : '‚úó');
            if (passed === true) state.results.pass++;
            else if (passed === false) state.results.fail++;
            else state.results.pending++;

            const div = document.createElement('div');
            div.className = `test-result ${status}`;
            div.innerHTML = `<span class="status">${icon}</span><span class="test-name">${name}</span><span class="test-detail">${detail}</span>`;
            section.appendChild(div);
            updateSummary();
            return div;
        }

        function addVisualTest(section, title, content) {
            const div = document.createElement('div');
            div.className = 'visual-test';
            div.innerHTML = `<h3>${title}</h3><div class="visual-preview">${content}</div>`;
            section.appendChild(div);
            return div;
        }

        // ========== PARSER TESTS ==========
        async function runParserTests() {
            const section = addSection('Parser Tests');

            // Test 1: Basic key-value
            const parser = new ParadoxParser();
            let result = parser.parse('key = value');
            addResult(section, 'Parse basic key-value', result.key === 'value', `key = "${result.key}"`);

            // Test 2: Nested blocks
            result = parser.parse('outer = { inner = 123 }');
            addResult(section, 'Parse nested blocks', result.outer?.inner === 123, `inner = ${result.outer?.inner}`);

            // Test 3: Boolean yes/no
            result = parser.parse('enabled = yes\ndisabled = no');
            addResult(section, 'Parse boolean yes', result.enabled === true);
            addResult(section, 'Parse boolean no', result.disabled === false);

            // Test 4: Numbers
            result = parser.parse('positive = 100\nnegative = -50\ndecimal = 0.75');
            addResult(section, 'Parse positive number', result.positive === 100);
            addResult(section, 'Parse negative number', result.negative === -50);
            addResult(section, 'Parse decimal', result.decimal === 0.75);

            // Test 5: Arrays
            result = parser.parse('list = { a b c }');
            addResult(section, 'Parse array', Array.isArray(result.list) && result.list.length === 3);

            // Test 6: RGB colors
            result = parser.parse('color = rgb { 255 128 64 }');
            addResult(section, 'Parse RGB color', result.color?._type === 'rgb' && result.color?.r === 255);

            // Test 7: Comments
            result = parser.parse('# comment\nkey = value # inline');
            addResult(section, 'Skip comments', result.key === 'value');

            // Test 8: Quoted strings
            result = parser.parse('name = "Hello World"');
            addResult(section, 'Parse quoted string', result.name === 'Hello World');

            // Test 9: Comparison operators
            result = parser.parse('check = { value > 10 }');
            addResult(section, 'Parse comparison operator', result.check?.value?.operator === '>');

            // Test 10: Real advance structure
            const advanceText = `
                test_advance = {
                    age = age_2_renaissance
                    depth = 0
                    requires = parent_advance
                    icon = test_icon
                    research_cost = 2.5
                }
            `;
            result = parser.parse(advanceText);
            const adv = result.test_advance;
            addResult(section, 'Parse advance - age', adv?.age === 'age_2_renaissance');
            addResult(section, 'Parse advance - depth', adv?.depth === 0);
            addResult(section, 'Parse advance - requires', adv?.requires === 'parent_advance');
            addResult(section, 'Parse advance - icon', adv?.icon === 'test_icon');
            addResult(section, 'Parse advance - cost', adv?.research_cost === 2.5);
        }

        // ========== TREE BUILDER TESTS ==========
        async function runTreeTests() {
            const section = addSection('Tree Builder Tests');

            if (state.files.size === 0) {
                addResult(section, 'Load EU5 folder first', null, 'Click "Load EU5 Folder"');
                return;
            }

            // Load advances
            const parser = new ParadoxParser();
            const advPath = 'game/in_game/common/advances';
            let fileCount = 0;

            for (const [path, file] of state.files) {
                if (path.startsWith(advPath + '/') && path.endsWith('.txt') && !path.substring(advPath.length + 1).includes('/')) {
                    const text = await file.text();
                    const parsed = parser.parse(text);
                    // Attach source file info
                    const fileName = path.split('/').pop().replace('.txt', '');
                    for (const key of Object.keys(parsed)) {
                        if (!key.startsWith('_')) {
                            parsed[key]._sourceFile = fileName;
                        }
                    }
                    Object.assign(state.rawData, parsed);
                    fileCount++;
                }
            }

            const keys = Object.keys(state.rawData).filter(k => !k.startsWith('_'));
            addResult(section, 'Load advance files', fileCount > 0, `${fileCount} files loaded`);
            addResult(section, 'Parse advances', keys.length > 100, `${keys.length} advances parsed`);

            // Test specific advances
            const renaissance = state.rawData.renaissance_advance;
            addResult(section, 'Find renaissance_advance', !!renaissance);
            addResult(section, 'renaissance_advance.age', renaissance?.age === 'age_2_renaissance', renaissance?.age);
            addResult(section, 'renaissance_advance.depth', renaissance?.depth === 0, `depth=${renaissance?.depth}`);

            const banking = state.rawData.banking_advance;
            addResult(section, 'Find banking_advance', !!banking);
            addResult(section, 'banking_advance has no requires', !banking?.requires, `requires=${banking?.requires}`);

            const renaissanceThought = state.rawData.renaissance_thought;
            addResult(section, 'Find renaissance_thought', !!renaissanceThought);
            addResult(section, 'renaissance_thought requires renaissance_advance',
                renaissanceThought?.requires === 'renaissance_advance',
                `requires=${renaissanceThought?.requires}`);

            // Build tree structure
            const advances = {};
            for (const key of keys) {
                const item = state.rawData[key];
                advances[key] = {
                    era: item.age || 'unknown',
                    depth: item.depth,
                    requires: item.requires ? (typeof item.requires === 'string' ? [item.requires] : item.requires) : [],
                    unlockedBy: [],
                    raw: item
                };
            }

            // Build reverse deps
            for (const [key, adv] of Object.entries(advances)) {
                for (const req of adv.requires) {
                    if (advances[req]) advances[req].unlockedBy.push(key);
                }
            }

            state.treeData = advances;

            // Test unlockedBy
            addResult(section, 'renaissance_advance.unlockedBy includes renaissance_thought',
                advances.renaissance_advance?.unlockedBy.includes('renaissance_thought'),
                advances.renaissance_advance?.unlockedBy.slice(0, 3).join(', '));

            addResult(section, 'banking_advance.unlockedBy includes merchants_and_trade',
                advances.banking_advance?.unlockedBy.includes('merchants_and_trade'),
                advances.banking_advance?.unlockedBy.slice(0, 3).join(', '));

            // Count by era
            const byEra = {};
            for (const [key, adv] of Object.entries(advances)) {
                byEra[adv.era] = (byEra[adv.era] || 0) + 1;
            }
            addResult(section, 'Has age_1_traditions', byEra.age_1_traditions > 100, `${byEra.age_1_traditions} advances`);
            addResult(section, 'Has age_2_renaissance', byEra.age_2_renaissance > 100, `${byEra.age_2_renaissance} advances`);

            // Count roots
            const age2 = Object.entries(advances).filter(([k, v]) => v.era === 'age_2_renaissance');
            const age2Roots = age2.filter(([k, v]) => {
                const internalReqs = v.requires.filter(r => advances[r]?.era === 'age_2_renaissance');
                return internalReqs.length === 0;
            });
            addResult(section, 'Age 2 has ~54 roots', age2Roots.length >= 50 && age2Roots.length <= 60, `${age2Roots.length} roots`);
        }

        // ========== FILTERING TESTS ==========
        async function runFilteringTests() {
            const section = addSection('Tech Tree Filtering Tests');

            if (state.files.size === 0 || Object.keys(state.rawData).length === 0) {
                addResult(section, 'Run Tree Builder tests first', null, 'Click "Test Tree Builder" first');
                return;
            }

            const raw = state.rawData;
            const keys = Object.keys(raw).filter(k => !k.startsWith('_'));

            // Test 1: Identify country-specific advances (have 'potential' block)
            const withPotential = keys.filter(k => raw[k].potential);
            addResult(section, 'Find country-specific advances (with potential)',
                withPotential.length > 0,
                `${withPotential.length} found. Examples: ${withPotential.slice(0, 3).join(', ')}`);

            // Test 2: Identify government-specific advances (have 'government' field)
            const withGovernment = keys.filter(k => raw[k].government);
            addResult(section, 'Find government-specific advances',
                withGovernment.length > 0,
                `${withGovernment.length} found. Examples: ${withGovernment.slice(0, 3).join(', ')}`);

            // Test 3: flesh_is_weak should have government field
            const fleshIsWeak = raw.flesh_is_weak;
            addResult(section, 'flesh_is_weak exists', !!fleshIsWeak);
            addResult(section, 'flesh_is_weak has government field',
                !!fleshIsWeak?.government,
                `government=${fleshIsWeak?.government}`);
            addResult(section, 'flesh_is_weak should be filtered out',
                fleshIsWeak?.government === 'theocracy',
                'Should not appear in universal tree');

            // Test 4: Identify choice advances (adm/dip/mil branches)
            const withFor = keys.filter(k => raw[k].for);
            addResult(section, 'Find choice advances (for field)',
                withFor.length > 0,
                `${withFor.length} found. Values: ${[...new Set(withFor.map(k => raw[k].for))].join(', ')}`);

            // Test 5: Identify country-type specific advances
            const withCountryType = keys.filter(k => raw[k].country_type);
            addResult(section, 'Find country-type specific advances',
                true,
                `${withCountryType.length} found. Values: ${[...new Set(withCountryType.map(k => raw[k].country_type))].join(', ')}`);

            // Test 6: Universal advances should have no restrictive fields
            const restrictiveFields = ['potential', 'government', 'for', 'country_type'];
            const universal = keys.filter(k => {
                const item = raw[k];
                return !restrictiveFields.some(f => item[f]);
            });
            addResult(section, 'Count universal advances',
                universal.length > 400,
                `${universal.length} universal out of ${keys.length} total`);

            // Test 7: Universal advances with no requirements (should be ~46 roots)
            const universalNoReqs = universal.filter(k => !raw[k].requires);
            addResult(section, 'Universal advances without requires field',
                universalNoReqs.length < 60,
                `${universalNoReqs.length} found (should be ~46 root nodes)`);

            // Test 8: Check for advances with requires pointing to filtered advances
            const governmentAdvanceKeys = new Set(withGovernment);
            const potentialAdvanceKeys = new Set(withPotential);
            const forAdvanceKeys = new Set(withFor);
            const countryTypeAdvanceKeys = new Set(withCountryType);
            const orphaned = universal.filter(k => {
                const item = raw[k];
                if (!item.requires) return false;
                const reqs = typeof item.requires === 'string' ? [item.requires] :
                             Array.isArray(item.requires) ? item.requires : [];
                // Check if ALL requirements are to filtered advances
                return reqs.length > 0 && reqs.every(r =>
                    governmentAdvanceKeys.has(r) || potentialAdvanceKeys.has(r) ||
                    forAdvanceKeys.has(r) || countryTypeAdvanceKeys.has(r) || !raw[r]
                );
            });
            addResult(section, 'Orphaned advances (reqs all filtered)',
                orphaned.length === 0,
                `${orphaned.length} found: ${orphaned.slice(0, 5).join(', ')}`);

            // Test 9: Log all unique government types
            const govTypes = [...new Set(withGovernment.map(k => raw[k].government))];
            addResult(section, 'Government types found',
                govTypes.length > 0,
                govTypes.join(', '));

            // Test 10: Analyze what fields non-universal advances have
            const nonUniversal = keys.filter(k => !universal.includes(k));
            const fieldCounts = {};
            for (const k of nonUniversal) {
                for (const field of Object.keys(raw[k])) {
                    if (!field.startsWith('_')) {
                        fieldCounts[field] = (fieldCounts[field] || 0) + 1;
                    }
                }
            }
            const topFields = Object.entries(fieldCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([f, c]) => `${f}(${c})`);
            addResult(section, 'Common fields in non-universal advances',
                true,
                topFields.join(', '));
        }

        // ========== VISUAL LAYOUT TESTS ==========
        async function runVisualTests() {
            const section = addSection('Visual Layout Tests');

            // Test 1: CSS Grid fills width
            addVisualTest(section, 'CSS Grid: Should show 3+ columns on wide screen',
                `<div class="grid-test">
                    <div class="grid-item">1</div>
                    <div class="grid-item">2</div>
                    <div class="grid-item">3</div>
                    <div class="grid-item">4</div>
                    <div class="grid-item">5</div>
                    <div class="grid-item">6</div>
                </div>`);

            // Check actual grid columns
            setTimeout(() => {
                const gridTest = document.querySelector('.grid-test');
                if (gridTest) {
                    const style = getComputedStyle(gridTest);
                    const cols = style.gridTemplateColumns.split(' ').length;
                    addResult(section, 'Grid has multiple columns', cols >= 2, `${cols} columns detected`);
                }
            }, 100);

            // Test 2: Tech node styling
            addVisualTest(section, 'Tech Node: Golden border, dark background',
                `<div style="background: linear-gradient(180deg, #1a2235 0%, #0f1520 100%); border: 2px solid #c9a227; border-radius: 4px; padding: 15px; max-width: 250px;">
                    <div style="text-align: center; font-size: 1.5rem; margin-bottom: 8px;">üé®</div>
                    <div style="text-align: center; font-weight: 600; color: #fff;">Renaissance Advance</div>
                    <div style="font-size: 0.7rem; color: #61afef; padding: 4px 8px; background: rgba(97, 175, 239, 0.1); border-radius: 3px; margin-top: 8px;">Requires: Written Alphabet</div>
                </div>`);

            // Test 3: Tier header
            addVisualTest(section, 'Tier Header: Gold label with count',
                `<div style="display: flex; align-items: center; gap: 12px; padding-bottom: 8px; border-bottom: 1px solid #0f3460;">
                    <span style="font-size: 1.1rem; font-weight: 600; color: #c9a227;">Root Advances</span>
                    <span style="font-size: 0.85rem; color: #888;">54 advances</span>
                </div>`);

            // Test 4: Era tabs
            addVisualTest(section, 'Era Tabs: One active, others inactive',
                `<div style="display: flex; background: #16213e; border-bottom: 1px solid #0f3460;">
                    <button style="padding: 12px 16px; background: none; border: none; color: #888; cursor: pointer;">I - Traditions</button>
                    <button style="padding: 12px 16px; background: #0f3460; border: none; color: #c9a227; border-bottom: 2px solid #c9a227;">II - Renaissance</button>
                    <button style="padding: 12px 16px; background: none; border: none; color: #888; cursor: pointer;">III - Discovery</button>
                </div>`);

            addResult(section, 'Visual tests rendered', true, 'Check visuals above');
        }

        // ========== RUN ALL ==========
        document.getElementById('run-all').onclick = async () => {
            output.innerHTML = '';
            state.results = { pass: 0, fail: 0, pending: 0 };
            updateSummary();
            await runParserTests();
            await runTreeTests();
            await runFilteringTests();
            await runVisualTests();
        };

        document.getElementById('run-parser').onclick = async () => {
            output.innerHTML = '';
            state.results = { pass: 0, fail: 0, pending: 0 };
            await runParserTests();
        };

        document.getElementById('run-tree').onclick = async () => {
            output.innerHTML = '';
            state.results = { pass: 0, fail: 0, pending: 0 };
            await runTreeTests();
        };

        document.getElementById('run-filtering').onclick = async () => {
            output.innerHTML = '';
            state.results = { pass: 0, fail: 0, pending: 0 };
            await runFilteringTests();
        };

        document.getElementById('run-visual').onclick = async () => {
            output.innerHTML = '';
            state.results = { pass: 0, fail: 0, pending: 0 };
            await runVisualTests();
        };

        // Auto-run parser tests on load
        runParserTests();
    </script>
</body>
</html>
